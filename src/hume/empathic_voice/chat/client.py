# This file was auto-generated by Fern from our API Definition.

from contextlib import asynccontextmanager, contextmanager

import json
import typing

from typing_extensions import deprecated

import httpx
import websockets.exceptions
import websockets.sync.client as websockets_sync_client
from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...core.query_encoder import single_query_encoder
from ..types.connect_session_settings import ConnectSessionSettings
from .raw_client import AsyncRawChatClient, RawChatClient
from .socket_client import AsyncChatSocketClient, ChatSocketClient, ChatConnectOptions

from ...core.events import EventEmitterMixin, EventType
from ...core.pydantic_utilities import parse_obj_as
from ..types.assistant_input import AssistantInput
from ..types.audio_input import AudioInput
from ..types.pause_assistant_message import PauseAssistantMessage
from ..types.resume_assistant_message import ResumeAssistantMessage
from ..types.session_settings import SessionSettings
from ..types.tool_error_message import ToolErrorMessage
from ..types.tool_response_message import ToolResponseMessage
from ..types.user_input import UserInput
from .types.publish_event import PublishEvent
from .types.subscribe_event import SubscribeEvent

from ...core.api_error import ApiError
import asyncio

from ...core.websocket import OnErrorHandlerType, OnMessageHandlerType, OnOpenCloseHandlerType

try:
    from websockets.legacy.client import connect as websockets_client_connect  # type: ignore
except ImportError:
    from websockets import connect as websockets_client_connect  # type: ignore

class ChatClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawChatClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawChatClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawChatClient
        """
        return self._raw_client

    @contextmanager
    def connect(
        self,
        *,
        access_token: typing.Optional[str] = None,
        config_id: typing.Optional[str] = None,
        config_version: typing.Optional[int] = None,
        event_limit: typing.Optional[int] = None,
        resumed_chat_group_id: typing.Optional[str] = None,
        verbose_transcription: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        session_settings: ConnectSessionSettings,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[ChatSocketClient]:
        """
        Chat with Empathic Voice Interface (EVI)

        Parameters
        ----------
        access_token : typing.Optional[str]
            Access token used for authenticating the client. If not provided, an `api_key` must be provided to authenticate.

            The access token is generated using both an API key and a Secret key, which provides an additional layer of security compared to using just an API key.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        config_id : typing.Optional[str]
            The unique identifier for an EVI configuration.

            Include this ID in your connection request to equip EVI with the Prompt, Language Model, Voice, and Tools associated with the specified configuration. If omitted, EVI will apply [default configuration settings](/docs/speech-to-speech-evi/configuration/build-a-configuration#default-configuration).

            For help obtaining this ID, see our [Configuration Guide](/docs/speech-to-speech-evi/configuration).

        config_version : typing.Optional[int]
            The version number of the EVI configuration specified by the `config_id`.

            Configs, as well as Prompts and Tools, are versioned. This versioning system supports iterative development, allowing you to progressively refine configurations and revert to previous versions if needed.

            Include this parameter to apply a specific version of an EVI configuration. If omitted, the latest version will be applied.

        event_limit : typing.Optional[int]
            The maximum number of chat events to return from chat history. By default, the system returns up to 300 events (100 events per page Ã— 3 pages). Set this parameter to a smaller value to limit the number of events returned.

        resumed_chat_group_id : typing.Optional[str]
            The unique identifier for a Chat Group. Use this field to preserve context from a previous Chat session.

            A Chat represents a single session from opening to closing a WebSocket connection. In contrast, a Chat Group is a series of resumed Chats that collectively represent a single conversation spanning multiple sessions. Each Chat includes a Chat Group ID, which is used to preserve the context of previous Chat sessions when starting a new one.

            Including the Chat Group ID in the `resumed_chat_group_id` query parameter is useful for seamlessly resuming a Chat after unexpected network disconnections and for picking up conversations exactly where you left off at a later time. This ensures preserved context across multiple sessions.

            There are three ways to obtain the Chat Group ID:

            - [Chat Metadata](/reference/speech-to-speech-evi/chat#receive.ChatMetadata): Upon establishing a WebSocket connection with EVI, the user receives a Chat Metadata message. This message contains a `chat_group_id`, which can be used to resume conversations within this chat group in future sessions.

            - [List Chats endpoint](/reference/speech-to-speech-evi/chats/list-chats): Use the GET `/v0/evi/chats` endpoint to obtain the Chat Group ID of individual Chat sessions. This endpoint lists all available Chat sessions and their associated Chat Group ID.

            - [List Chat Groups endpoint](/reference/speech-to-speech-evi/chat-groups/list-chat-groups): Use the GET `/v0/evi/chat_groups` endpoint to obtain the Chat Group IDs of all Chat Groups associated with an API key. This endpoint returns a list of all available chat groups.

        verbose_transcription : typing.Optional[bool]
            A flag to enable verbose transcription. Set this query parameter to `true` to have unfinalized user transcripts be sent to the client as interim UserMessage messages. The [interim](/reference/speech-to-speech-evi/chat#receive.UserMessage.interim) field on a [UserMessage](/reference/speech-to-speech-evi/chat#receive.UserMessage) denotes whether the message is "interim" or "final."

        api_key : typing.Optional[str]
            API key used for authenticating the client. If not provided, an `access_token` must be provided to authenticate.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        session_settings : ConnectSessionSettings

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatSocketClient
        """
        ws_url = self._raw_client._client_wrapper.get_environment().evi + "/chat"
        query_params = httpx.QueryParams()
        if access_token is not None:
            query_params = query_params.add("access_token", access_token)
        if config_id is not None:
            query_params = query_params.add("config_id", config_id)
        if config_version is not None:
            query_params = query_params.add("config_version", config_version)
        if event_limit is not None:
            query_params = query_params.add("event_limit", event_limit)
        if resumed_chat_group_id is not None:
            query_params = query_params.add("resumed_chat_group_id", resumed_chat_group_id)
        if verbose_transcription is not None:
            query_params = query_params.add("verbose_transcription", verbose_transcription)
        if api_key is not None:
            query_params = query_params.add("api_key", api_key)
        if session_settings is not None:
            flattened_params = single_query_encoder("session_settings", session_settings)
            for param_key, param_value in flattened_params:
                query_params = query_params.add(param_key, str(param_value))
        ws_url = ws_url + f"?{query_params}"
        headers = self._raw_client._client_wrapper.get_headers()
        if request_options and "additional_headers" in request_options:
            headers.update(request_options["additional_headers"])
        try:
            with websockets_sync_client.connect(ws_url, additional_headers=headers) as protocol:
                yield ChatSocketClient(websocket=protocol)
        except websockets.exceptions.InvalidStatusCode as exc:
            status_code: int = exc.status_code
            if status_code == 401:
                raise ApiError(
                    status_code=status_code,
                    headers=dict(headers),
                    body="Websocket initialized with invalid credentials.",
                )
            raise ApiError(
                status_code=status_code,
                headers=dict(headers),
                body="Unexpected error when initializing websocket connection.",
            )


class AsyncChatClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawChatClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawChatClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawChatClient
        """
        return self._raw_client

    @asynccontextmanager
    async def connect(
        self,
        *,
        access_token: typing.Optional[str] = None,
        config_id: typing.Optional[str] = None,
        config_version: typing.Optional[int] = None,
        event_limit: typing.Optional[int] = None,
        resumed_chat_group_id: typing.Optional[str] = None,
        verbose_transcription: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        session_settings: typing.Optional[ConnectSessionSettings] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncChatSocketClient]:
        """
        Chat with Empathic Voice Interface (EVI)

        Parameters
        ----------
        access_token : typing.Optional[str]
            Access token used for authenticating the client. If not provided, an `api_key` must be provided to authenticate.

            The access token is generated using both an API key and a Secret key, which provides an additional layer of security compared to using just an API key.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        config_id : typing.Optional[str]
            The unique identifier for an EVI configuration.

            Include this ID in your connection request to equip EVI with the Prompt, Language Model, Voice, and Tools associated with the specified configuration. If omitted, EVI will apply [default configuration settings](/docs/speech-to-speech-evi/configuration/build-a-configuration#default-configuration).

            For help obtaining this ID, see our [Configuration Guide](/docs/speech-to-speech-evi/configuration).

        config_version : typing.Optional[int]
            The version number of the EVI configuration specified by the `config_id`.

            Configs, as well as Prompts and Tools, are versioned. This versioning system supports iterative development, allowing you to progressively refine configurations and revert to previous versions if needed.

            Include this parameter to apply a specific version of an EVI configuration. If omitted, the latest version will be applied.

        event_limit : typing.Optional[int]
            The maximum number of chat events to return from chat history. By default, the system returns up to 300 events (100 events per page Ã— 3 pages). Set this parameter to a smaller value to limit the number of events returned.

        resumed_chat_group_id : typing.Optional[str]
            The unique identifier for a Chat Group. Use this field to preserve context from a previous Chat session.

            A Chat represents a single session from opening to closing a WebSocket connection. In contrast, a Chat Group is a series of resumed Chats that collectively represent a single conversation spanning multiple sessions. Each Chat includes a Chat Group ID, which is used to preserve the context of previous Chat sessions when starting a new one.

            Including the Chat Group ID in the `resumed_chat_group_id` query parameter is useful for seamlessly resuming a Chat after unexpected network disconnections and for picking up conversations exactly where you left off at a later time. This ensures preserved context across multiple sessions.

            There are three ways to obtain the Chat Group ID:

            - [Chat Metadata](/reference/speech-to-speech-evi/chat#receive.ChatMetadata): Upon establishing a WebSocket connection with EVI, the user receives a Chat Metadata message. This message contains a `chat_group_id`, which can be used to resume conversations within this chat group in future sessions.

            - [List Chats endpoint](/reference/speech-to-speech-evi/chats/list-chats): Use the GET `/v0/evi/chats` endpoint to obtain the Chat Group ID of individual Chat sessions. This endpoint lists all available Chat sessions and their associated Chat Group ID.

            - [List Chat Groups endpoint](/reference/speech-to-speech-evi/chat-groups/list-chat-groups): Use the GET `/v0/evi/chat_groups` endpoint to obtain the Chat Group IDs of all Chat Groups associated with an API key. This endpoint returns a list of all available chat groups.

        verbose_transcription : typing.Optional[bool]
            A flag to enable verbose transcription. Set this query parameter to `true` to have unfinalized user transcripts be sent to the client as interim UserMessage messages. The [interim](/reference/speech-to-speech-evi/chat#receive.UserMessage.interim) field on a [UserMessage](/reference/speech-to-speech-evi/chat#receive.UserMessage) denotes whether the message is "interim" or "final."

        api_key : typing.Optional[str]
            API key used for authenticating the client. If not provided, an `access_token` must be provided to authenticate.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        session_settings : ConnectSessionSettings

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncChatSocketClient
        """
        ws_url = self._raw_client._client_wrapper.get_environment().evi + "/chat"
        query_params = httpx.QueryParams()
        if access_token is not None:
            query_params = query_params.add("access_token", access_token)
        if config_id is not None:
            query_params = query_params.add("config_id", config_id)
        if config_version is not None:
            query_params = query_params.add("config_version", config_version)
        if event_limit is not None:
            query_params = query_params.add("event_limit", event_limit)
        if resumed_chat_group_id is not None:
            query_params = query_params.add("resumed_chat_group_id", resumed_chat_group_id)
        if verbose_transcription is not None:
            query_params = query_params.add("verbose_transcription", verbose_transcription)
        if api_key is not None:
            query_params = query_params.add("api_key", api_key)
        if session_settings is not None:
            flattened_params = single_query_encoder("session_settings", session_settings)
            for param_key, param_value in flattened_params:
                query_params = query_params.add(param_key, str(param_value))
        ws_url = ws_url + f"?{query_params}"
        headers = self._raw_client._client_wrapper.get_headers()
        if request_options and "additional_headers" in request_options:
            headers.update(request_options["additional_headers"])
        try:
            async with websockets_client_connect(ws_url, extra_headers=headers) as protocol:
                yield AsyncChatSocketClient(websocket=protocol)
        except websockets.exceptions.InvalidStatusCode as exc:
            status_code: int = exc.status_code
            if status_code == 401:
                raise ApiError(
                    status_code=status_code,
                    headers=dict(headers),
                    body="Websocket initialized with invalid credentials.",
                )
            raise ApiError(
                status_code=status_code,
                headers=dict(headers),
                body="Unexpected error when initializing websocket connection.",
            )
        
    @deprecated("")
    async def _wrap_on_open_close(
        self, on_open: typing.Optional[OnOpenCloseHandlerType]
    ):
        if on_open is not None:
            if asyncio.iscoroutinefunction(on_open):
                await on_open()
            else:
                on_open()    

    @deprecated("")
    async def _wrap_on_error(
        self, exc: Exception, on_error: typing.Optional[OnErrorHandlerType]
    ) -> None:
        if on_error is not None:
            if asyncio.iscoroutinefunction(on_error):
                await on_error(exc)
            else:
                on_error(exc)

    @deprecated("")
    async def _wrap_on_message(
        self,
        message: SubscribeEvent,
        on_message: typing.Optional[OnMessageHandlerType[SubscribeEvent]],
    ) -> None:
        if on_message is not None:
            if asyncio.iscoroutinefunction(on_message):
                await on_message(message)
            else:
                on_message(message)

    async def _process_connection(
        self,
        connection: AsyncChatSocketClient,
        on_message: typing.Optional[OnMessageHandlerType],
        on_error: typing.Optional[OnErrorHandlerType],
    ) -> None:
        async for message in connection:
            try:
                await self._wrap_on_message(message, on_message)
            except Exception as exc:
                await self._wrap_on_error(exc, on_error)

    def _construct_ws_uri(self, options: typing.Optional[ChatConnectOptions]):
        query_params = httpx.QueryParams()

        api_key = self._raw_client._client_wrapper.api_key
        if options is not None:
            maybe_api_key = options.get("api_key")
            if maybe_api_key is not None:
                api_key = maybe_api_key
            maybe_config_id = options.get("config_id")
            if maybe_config_id is not None:
                query_params = query_params.add("config_id", maybe_config_id)
            maybe_config_version = options.get("config_version")
            if maybe_config_version is not None:
                query_params = query_params.add(
                    "config_version", maybe_config_version
                )
            maybe_resumed_chat_group_id = options.get("resumed_chat_group_id")
            if maybe_resumed_chat_group_id is not None:
                query_params = query_params.add(
                    "resumed_chat_group_id", maybe_resumed_chat_group_id
                )
            maybe_verbose_transcription = options.get("verbose_transcription")
            if maybe_verbose_transcription is not None:
                query_params = query_params.add(
                    "verbose_transcription",
                    "true" if maybe_verbose_transcription else "false",
                )
            elif api_key is not None:
                query_params = query_params.add("apiKey", api_key)

            maybe_voice_id = options.get("voice_id")
            if maybe_voice_id is not None:
                query_params = query_params.add("voice_id", maybe_voice_id)

            maybe_session_settings = options.get("session_settings")
            if maybe_session_settings is not None:
                # Handle audio settings
                audio = maybe_session_settings.get("audio")
                if audio is not None:
                    channels = audio.get("channels")
                    if channels is not None:
                        query_params = query_params.add(
                            "session_settings[audio][channels]", str(channels)
                        )
                    encoding = audio.get("encoding")
                    if encoding is not None:
                        query_params = query_params.add(
                            "session_settings[audio][encoding]", str(encoding)
                        )
                    sample_rate = audio.get("sample_rate")
                    if sample_rate is not None:
                        query_params = query_params.add(
                            "session_settings[audio][sample_rate]", str(sample_rate)
                        )

                # Handle context settings
                context = maybe_session_settings.get("context")
                if context is not None:
                    text = context.get("text")
                    if text is not None:
                        query_params = query_params.add(
                            "session_settings[context][text]", str(text)
                        )
                    context_type = context.get("type")
                    if context_type is not None:
                        query_params = query_params.add(
                            "session_settings[context][type]", str(context_type)
                        )

                # Handle top-level session settings
                custom_session_id = maybe_session_settings.get("custom_session_id")
                if custom_session_id is not None:
                    query_params = query_params.add(
                        "session_settings[custom_session_id]", str(custom_session_id)
                    )

                event_limit = maybe_session_settings.get("event_limit")
                if event_limit is not None:
                    query_params = query_params.add(
                        "session_settings[event_limit]", str(event_limit)
                    )

                language_model_api_key = maybe_session_settings.get("language_model_api_key")
                if language_model_api_key is not None:
                    query_params = query_params.add(
                        "session_settings[language_model_api_key]", str(language_model_api_key)
                    )

                system_prompt = maybe_session_settings.get("system_prompt")
                if system_prompt is not None:
                    query_params = query_params.add(
                        "session_settings[system_prompt]", str(system_prompt)
                    )

                variables = maybe_session_settings.get("variables")
                if variables is not None:
                    query_params = query_params.add(
                        "session_settings[variables]", json.dumps(variables)
                    )

                voice_id_setting = maybe_session_settings.get("voice_id")
                if voice_id_setting is not None:
                    query_params = query_params.add(
                        "session_settings[voice_id]", str(voice_id_setting)
                    )
        elif api_key is not None:
            query_params = query_params.add("apiKey", api_key)

        base = self._raw_client._client_wrapper.get_environment().evi + "/chat"
        return f"{base}?{query_params}"

    @deprecated("Use .on() instead.")
    @asynccontextmanager
    async def connect_with_callbacks(
        self,
        options: typing.Optional[ChatConnectOptions] = None,
        on_open: typing.Optional[OnOpenCloseHandlerType] = None,
        on_message: typing.Optional[OnMessageHandlerType[SubscribeEvent]] = None,
        on_close: typing.Optional[OnOpenCloseHandlerType] = None,
        on_error: typing.Optional[OnErrorHandlerType] = None,
    ) -> typing.AsyncIterator["AsyncChatSocketClient"]:
        """
        Parameters
        ----------
        on_open : Optional[OnOpenCloseHandlerType]
            A callable to be invoked on the opening of the websocket connection.

        on_message : Optional[OnMessageHandlerType[SubscribeEvent]]
            A callable to be invoked on receiving a message from the websocket connection. This callback should expect a `SubscribeEvent` object.

        on_close : Optional[OnOpenCloseHandlerType]
            A callable to be invoked on the closing of the websocket connection.

        on_error : Optional[OnErrorHandlerType]
            A callable to be invoked on receiving an error from the websocket connection.

        Yields
        -------
        AsyncIterator["AsyncChatSocketClient"]
        """

        ws_uri = self._construct_ws_uri(options)

        background_task: typing.Optional[asyncio.Task[None]] = None

        try:
            async with websockets.connect(
                ws_uri,
                extra_headers=self._raw_client._client_wrapper.get_headers(),
            ) as protocol:
                await self._wrap_on_open_close(on_open)
                connection = AsyncChatSocketClient(websocket=protocol)
                background_task = asyncio.create_task(
                    self._process_connection(connection, on_message, on_error)
                )

                yield connection

        # Special case authentication errors
        except websockets.exceptions.InvalidStatusCode as exc:
            status_code: int = exc.status_code
            if status_code == 401:
                raise ApiError(
                    status_code=status_code,
                    body="Websocket initialized with invalid credentials.",
                ) from exc
            raise ApiError(
                status_code=status_code,
                body="Unexpected error when initializing websocket connection.",
            ) from exc

        # Except all other errors to apply the on_error handler
        except Exception as exc:
            await self._wrap_on_error(exc, on_error)
            raise

        # Finally, apply the on_close handler
        finally:
            if background_task is not None:
                background_task.cancel()
                try:
                    await background_task
                except asyncio.CancelledError:
                    pass
            await self._wrap_on_open_close(on_close)

