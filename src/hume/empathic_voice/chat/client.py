# This file was auto-generated by Fern from our API Definition.

from contextlib import asynccontextmanager, contextmanager

from typing_extensions import deprecated

import httpx
import websockets.exceptions
import websockets.sync.client as websockets_sync_client
from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ..types.connect_session_settings import ConnectSessionSettings
from .raw_client import AsyncRawChatClient, RawChatClient
from .socket_client import AsyncChatSocketClient, ChatSocketClient

from ...core.events import EventEmitterMixin, EventType
from ...core.pydantic_utilities import parse_obj_as
from ..types.assistant_input import AssistantInput
from ..types.audio_input import AudioInput
from ..types.pause_assistant_message import PauseAssistantMessage
from ..types.resume_assistant_message import ResumeAssistantMessage
from ..types.session_settings import SessionSettings
from ..types.tool_error_message import ToolErrorMessage
from ..types.tool_response_message import ToolResponseMessage
from ..types.user_input import UserInput
from .types.publish_event import PublishEvent
from .types.subscribe_event import SubscribeEvent

from ...core.api_error import ApiError
import asyncio


try:
    from websockets.legacy.client import connect as websockets_client_connect  # type: ignore
except ImportError:
    from websockets import connect as websockets_client_connect  # type: ignore

import typing

OnOpenCloseHandlerType = typing.Union[typing.Callable[[], None], typing.Callable[[], typing.Awaitable[None]]]

MessageT = typing.TypeVar('MessageT')
OnMessageHandlerType = typing.Union[typing.Callable[[MessageT], None], typing.Callable[[MessageT], typing.Awaitable[None]]]

OnErrorHandlerType = typing.Union[typing.Callable[[Exception], None], typing.Callable[[Exception], typing.Awaitable[None]]]

@deprecated("Use .connect() with kwargs instead.")
class ChatConnectOptions(typing.TypedDict, total=False):
    voice_id: typing.Optional[str]
    # DEFAULT_NUM_CHANNELS: typing.ClassVar[int] = 1
    # DEFAULT_SAMPLE_RATE: typing.ClassVar[int] = 44_100

    def __init__(
        self,
        *,
        websocket: websockets.WebSocketClientProtocol,
    ):
        self.websocket = websocket

        # self._num_channels = self.DEFAULT_NUM_CHANNELS
        # self._sample_rate = self.DEFAULT_SAMPLE_RATE

    async def __aiter__(self):
        async for message in self.websocket:
            yield parse_obj_as(SubscribeEvent, json.loads(message))  # type: ignore

    async def _send(self, data: typing.Any) -> None:
        if isinstance(data, dict):
            data = json.dumps(data)
        await self.websocket.send(data)

    async def recv(self) -> SubscribeEvent:
        data = await self.websocket.recv()
        return parse_obj_as(SubscribeEvent, json.loads(data))  # type: ignore

    async def _send_model(self, data: PublishEvent) -> None:
        await self._send(data.dict())

    async def send_audio_input(self, message: AudioInput) -> None:
        """
        Parameters
        ----------
        message : AudioInput

        Returns
        -------
        None
        """
        await self._send_model(message)

    async def send_session_settings(self, message: SessionSettings) -> None:
        """
        Update the EVI session settings.

        Parameters
        ----------
        message : SessionSettings

        Returns
        -------
        None
        """

        # Update sample rate and channels
        if message.audio is not None:
            if message.audio.channels is not None:
                self._num_channels = message.audio.channels
            if message.audio.sample_rate is not None:
                self._sample_rate = message.audio.sample_rate

        await self._send_model(message)

    async def send_user_input(self, message: UserInput) -> None:
        """
        Parameters
        ----------
        message : UserInput

        Returns
        -------
        None
        """
        await self._send_model(message)

    async def send_assistant_input(self, message: AssistantInput) -> None:
        """
        Parameters
        ----------
        message : AssistantInput

        Returns
        -------
        None
        """
        await self._send_model(message)

    async def send_tool_response(self, message: ToolResponseMessage) -> None:
        """
        Parameters
        ----------
        message : ToolResponseMessage

        Returns
        -------
        None
        """
        await self._send_model(message)

    async def send_tool_error(self, message: ToolErrorMessage) -> None:
        """
        Parameters
        ----------
        message : ToolErrorMessage

        Returns
        -------
        None
        """
        await self._send_model(message)

    async def send_pause_assistant(self, message: PauseAssistantMessage) -> None:
        """
        Parameters
        ----------
        message : PauseAssistantMessage

        Returns
        -------
        None
        """
        await self._send_model(message)

    async def send_resume_assistant(self, message: ResumeAssistantMessage) -> None:
        """
        Parameters
        ----------
        message : ResumeAssistantMessage

        Returns
        -------
        None
        """
        await self._send_model(message)


class ChatClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawChatClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawChatClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawChatClient
        """
        return self._raw_client

    @contextmanager
    def connect(
        self,
        *,
        access_token: typing.Optional[str] = None,
        config_id: typing.Optional[str] = None,
        config_version: typing.Optional[int] = None,
        event_limit: typing.Optional[int] = None,
        resumed_chat_group_id: typing.Optional[str] = None,
        verbose_transcription: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        session_settings: ConnectSessionSettings,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[ChatSocketClient]:
        """
        Chat with Empathic Voice Interface (EVI)

        Parameters
        ----------
        access_token : typing.Optional[str]
            Access token used for authenticating the client. If not provided, an `api_key` must be provided to authenticate.

            The access token is generated using both an API key and a Secret key, which provides an additional layer of security compared to using just an API key.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        config_id : typing.Optional[str]
            The unique identifier for an EVI configuration.

            Include this ID in your connection request to equip EVI with the Prompt, Language Model, Voice, and Tools associated with the specified configuration. If omitted, EVI will apply [default configuration settings](/docs/speech-to-speech-evi/configuration/build-a-configuration#default-configuration).

            For help obtaining this ID, see our [Configuration Guide](/docs/speech-to-speech-evi/configuration).

        config_version : typing.Optional[int]
            The version number of the EVI configuration specified by the `config_id`.

            Configs, as well as Prompts and Tools, are versioned. This versioning system supports iterative development, allowing you to progressively refine configurations and revert to previous versions if needed.

            Include this parameter to apply a specific version of an EVI configuration. If omitted, the latest version will be applied.

        event_limit : typing.Optional[int]
            The maximum number of chat events to return from chat history. By default, the system returns up to 300 events (100 events per page Ã— 3 pages). Set this parameter to a smaller value to limit the number of events returned.

        resumed_chat_group_id : typing.Optional[str]
            The unique identifier for a Chat Group. Use this field to preserve context from a previous Chat session.

            A Chat represents a single session from opening to closing a WebSocket connection. In contrast, a Chat Group is a series of resumed Chats that collectively represent a single conversation spanning multiple sessions. Each Chat includes a Chat Group ID, which is used to preserve the context of previous Chat sessions when starting a new one.

            Including the Chat Group ID in the `resumed_chat_group_id` query parameter is useful for seamlessly resuming a Chat after unexpected network disconnections and for picking up conversations exactly where you left off at a later time. This ensures preserved context across multiple sessions.

            There are three ways to obtain the Chat Group ID:

            - [Chat Metadata](/reference/speech-to-speech-evi/chat#receive.ChatMetadata): Upon establishing a WebSocket connection with EVI, the user receives a Chat Metadata message. This message contains a `chat_group_id`, which can be used to resume conversations within this chat group in future sessions.

            - [List Chats endpoint](/reference/speech-to-speech-evi/chats/list-chats): Use the GET `/v0/evi/chats` endpoint to obtain the Chat Group ID of individual Chat sessions. This endpoint lists all available Chat sessions and their associated Chat Group ID.

            - [List Chat Groups endpoint](/reference/speech-to-speech-evi/chat-groups/list-chat-groups): Use the GET `/v0/evi/chat_groups` endpoint to obtain the Chat Group IDs of all Chat Groups associated with an API key. This endpoint returns a list of all available chat groups.

        verbose_transcription : typing.Optional[bool]
            A flag to enable verbose transcription. Set this query parameter to `true` to have unfinalized user transcripts be sent to the client as interim UserMessage messages. The [interim](/reference/speech-to-speech-evi/chat#receive.UserMessage.interim) field on a [UserMessage](/reference/speech-to-speech-evi/chat#receive.UserMessage) denotes whether the message is "interim" or "final."

        api_key : typing.Optional[str]
            API key used for authenticating the client. If not provided, an `access_token` must be provided to authenticate.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        session_settings : ConnectSessionSettings

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatSocketClient
        """
        ws_url = self._raw_client._client_wrapper.get_environment().evi + "/chat"
        query_params = httpx.QueryParams()
        if access_token is not None:
            query_params = query_params.add("access_token", access_token)
        if config_id is not None:
            query_params = query_params.add("config_id", config_id)
        if config_version is not None:
            query_params = query_params.add("config_version", config_version)
        if event_limit is not None:
            query_params = query_params.add("event_limit", event_limit)
        if resumed_chat_group_id is not None:
            query_params = query_params.add("resumed_chat_group_id", resumed_chat_group_id)
        if verbose_transcription is not None:
            query_params = query_params.add("verbose_transcription", verbose_transcription)
        if api_key is not None:
            query_params = query_params.add("api_key", api_key)
        if (
            convert_and_respect_annotation_metadata(
                object_=session_settings, annotation=ConnectSessionSettings, direction="write"
            )
            is not None
        ):
            query_params = query_params.add(
                "session_settings",
                convert_and_respect_annotation_metadata(
                    object_=session_settings, annotation=ConnectSessionSettings, direction="write"
                ),
            )
        ws_url = ws_url + f"?{query_params}"
        headers = self._raw_client._client_wrapper.get_headers()
        if request_options and "additional_headers" in request_options:
            headers.update(request_options["additional_headers"])
        try:
            with websockets_sync_client.connect(ws_url, additional_headers=headers) as protocol:
                yield ChatSocketClient(websocket=protocol)
        except websockets.exceptions.InvalidStatusCode as exc:
            status_code: int = exc.status_code
            if status_code == 401:
                raise ApiError(
                    status_code=status_code,
                    headers=dict(headers),
                    body="Websocket initialized with invalid credentials.",
                )
            raise ApiError(
                status_code=status_code,
                headers=dict(headers),
                body="Unexpected error when initializing websocket connection.",
            )


class AsyncChatClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawChatClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawChatClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawChatClient
        """
        return self._raw_client

    @asynccontextmanager
    async def connect(
        self,
        *,
        access_token: typing.Optional[str] = None,
        config_id: typing.Optional[str] = None,
        config_version: typing.Optional[int] = None,
        event_limit: typing.Optional[int] = None,
        resumed_chat_group_id: typing.Optional[str] = None,
        verbose_transcription: typing.Optional[bool] = None,
        api_key: typing.Optional[str] = None,
        session_settings: typing.Optional[ConnectSessionSettings] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncChatSocketClient]:
        """
        Chat with Empathic Voice Interface (EVI)

        Parameters
        ----------
        access_token : typing.Optional[str]
            Access token used for authenticating the client. If not provided, an `api_key` must be provided to authenticate.

            The access token is generated using both an API key and a Secret key, which provides an additional layer of security compared to using just an API key.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        config_id : typing.Optional[str]
            The unique identifier for an EVI configuration.

            Include this ID in your connection request to equip EVI with the Prompt, Language Model, Voice, and Tools associated with the specified configuration. If omitted, EVI will apply [default configuration settings](/docs/speech-to-speech-evi/configuration/build-a-configuration#default-configuration).

            For help obtaining this ID, see our [Configuration Guide](/docs/speech-to-speech-evi/configuration).

        config_version : typing.Optional[int]
            The version number of the EVI configuration specified by the `config_id`.

            Configs, as well as Prompts and Tools, are versioned. This versioning system supports iterative development, allowing you to progressively refine configurations and revert to previous versions if needed.

            Include this parameter to apply a specific version of an EVI configuration. If omitted, the latest version will be applied.

        event_limit : typing.Optional[int]
            The maximum number of chat events to return from chat history. By default, the system returns up to 300 events (100 events per page Ã— 3 pages). Set this parameter to a smaller value to limit the number of events returned.

        resumed_chat_group_id : typing.Optional[str]
            The unique identifier for a Chat Group. Use this field to preserve context from a previous Chat session.

            A Chat represents a single session from opening to closing a WebSocket connection. In contrast, a Chat Group is a series of resumed Chats that collectively represent a single conversation spanning multiple sessions. Each Chat includes a Chat Group ID, which is used to preserve the context of previous Chat sessions when starting a new one.

            Including the Chat Group ID in the `resumed_chat_group_id` query parameter is useful for seamlessly resuming a Chat after unexpected network disconnections and for picking up conversations exactly where you left off at a later time. This ensures preserved context across multiple sessions.

            There are three ways to obtain the Chat Group ID:

            - [Chat Metadata](/reference/speech-to-speech-evi/chat#receive.ChatMetadata): Upon establishing a WebSocket connection with EVI, the user receives a Chat Metadata message. This message contains a `chat_group_id`, which can be used to resume conversations within this chat group in future sessions.

            - [List Chats endpoint](/reference/speech-to-speech-evi/chats/list-chats): Use the GET `/v0/evi/chats` endpoint to obtain the Chat Group ID of individual Chat sessions. This endpoint lists all available Chat sessions and their associated Chat Group ID.

            - [List Chat Groups endpoint](/reference/speech-to-speech-evi/chat-groups/list-chat-groups): Use the GET `/v0/evi/chat_groups` endpoint to obtain the Chat Group IDs of all Chat Groups associated with an API key. This endpoint returns a list of all available chat groups.

        verbose_transcription : typing.Optional[bool]
            A flag to enable verbose transcription. Set this query parameter to `true` to have unfinalized user transcripts be sent to the client as interim UserMessage messages. The [interim](/reference/speech-to-speech-evi/chat#receive.UserMessage.interim) field on a [UserMessage](/reference/speech-to-speech-evi/chat#receive.UserMessage) denotes whether the message is "interim" or "final."

        api_key : typing.Optional[str]
            API key used for authenticating the client. If not provided, an `access_token` must be provided to authenticate.

            For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).

        session_settings : ConnectSessionSettings

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncChatSocketClient
        """
        ws_url = self._raw_client._client_wrapper.get_environment().evi + "/chat"
        query_params = httpx.QueryParams()
        if access_token is not None:
            query_params = query_params.add("access_token", access_token)
        if config_id is not None:
            query_params = query_params.add("config_id", config_id)
        if config_version is not None:
            query_params = query_params.add("config_version", config_version)
        if event_limit is not None:
            query_params = query_params.add("event_limit", event_limit)
        if resumed_chat_group_id is not None:
            query_params = query_params.add("resumed_chat_group_id", resumed_chat_group_id)
        if verbose_transcription is not None:
            query_params = query_params.add("verbose_transcription", verbose_transcription)
        if api_key is not None:
            query_params = query_params.add("api_key", api_key)
        if (
            convert_and_respect_annotation_metadata(
                object_=session_settings, annotation=ConnectSessionSettings, direction="write"
            )
            is not None
        ):
            query_params = query_params.add(
                "session_settings",
                convert_and_respect_annotation_metadata(
                    object_=session_settings, annotation=ConnectSessionSettings, direction="write"
                ),
            )
        ws_url = ws_url + f"?{query_params}"
        headers = self._raw_client._client_wrapper.get_headers()
        if request_options and "additional_headers" in request_options:
            headers.update(request_options["additional_headers"])
        try:
            async with websockets_client_connect(ws_url, extra_headers=headers) as protocol:
                yield AsyncChatSocketClient(websocket=protocol)
        except websockets.exceptions.InvalidStatusCode as exc:
            status_code: int = exc.status_code
            if status_code == 401:
                raise ApiError(
                    status_code=status_code,
                    headers=dict(headers),
                    body="Websocket initialized with invalid credentials.",
                )
            raise ApiError(
                status_code=status_code,
                headers=dict(headers),
                body="Unexpected error when initializing websocket connection.",
            )
        
    @deprecated("")
    async def _wrap_on_open_close(
        self, on_open: typing.Optional[OnOpenCloseHandlerType]
    ):
        if on_open is not None:
            if asyncio.iscoroutinefunction(on_open):
                await on_open()
            else:
                on_open()    

    @deprecated("")
    async def _wrap_on_error(
        self, exc: Exception, on_error: typing.Optional[OnErrorHandlerType]
    ) -> None:
        if on_error is not None:
            if asyncio.iscoroutinefunction(on_error):
                await on_error(exc)
            else:
                on_error(exc)

    @deprecated("")
    async def _wrap_on_message(
        self,
        message: SubscribeEvent,
        on_message: typing.Optional[OnMessageHandlerType[SubscribeEvent]],
    ) -> None:
        if on_message is not None:
            if asyncio.iscoroutinefunction(on_message):
                await on_message(message)
            else:
                on_message(message)

    async def _process_connection(
        self,
        connection: AsyncChatSocketClient,
        on_message: typing.Optional[OnMessageHandlerType],
        on_error: typing.Optional[OnErrorHandlerType],
    ) -> None:
        async for message in connection:
            try:
                await self._wrap_on_message(message, on_message)
            except Exception as exc:
                await self._wrap_on_error(exc, on_error)

    @deprecated("Use .on() instead.")
    @asynccontextmanager
    async def connect_with_callbacks(
        self,
        options: typing.Optional[ChatConnectOptions] = None,
        on_open: typing.Optional[OnOpenCloseHandlerType] = None,
        on_message: typing.Optional[OnMessageHandlerType[SubscribeEvent]] = None,
        on_close: typing.Optional[OnOpenCloseHandlerType] = None,
        on_error: typing.Optional[OnErrorHandlerType] = None,
    ) -> typing.AsyncIterator["AsyncChatSocketClient"]:
        """
        Parameters
        ----------
        on_open : Optional[OnOpenCloseHandlerType]
            A callable to be invoked on the opening of the websocket connection.

        on_message : Optional[OnMessageHandlerType[SubscribeEvent]]
            A callable to be invoked on receiving a message from the websocket connection. This callback should expect a `SubscribeEvent` object.

        on_close : Optional[OnOpenCloseHandlerType]
            A callable to be invoked on the closing of the websocket connection.

        on_error : Optional[OnErrorHandlerType]
            A callable to be invoked on receiving an error from the websocket connection.

        Yields
        -------
        AsyncIterator["AsyncChatSocketClient"]
        """

        ws_uri = self._raw_client._client_wrapper.get_environment().evi + "/chat"

        background_task: typing.Optional[asyncio.Task[None]] = None

        try:
            async with websockets.connect(
                ws_uri,
                extra_headers=self._raw_client._client_wrapper.get_headers(),
            ) as protocol:
                await self._wrap_on_open_close(on_open)
                connection = AsyncChatSocketClient(websocket=protocol)
                background_task = asyncio.create_task(
                    self._process_connection(connection, on_message, on_error)
                )

                yield connection

        # Special case authentication errors
        except websockets.exceptions.InvalidStatusCode as exc:
            status_code: int = exc.status_code
            if status_code == 401:
                raise ApiError(
                    status_code=status_code,
                    body="Websocket initialized with invalid credentials.",
                ) from exc
            raise ApiError(
                status_code=status_code,
                body="Unexpected error when initializing websocket connection.",
            ) from exc

        # Except all other errors to apply the on_error handler
        except Exception as exc:
            await self._wrap_on_error(exc, on_error)
            raise

        # Finally, apply the on_close handler
        finally:
            if background_task is not None:
                background_task.cancel()
                try:
                    await background_task
                except asyncio.CancelledError:
                    pass
            await self._wrap_on_open_close(on_close)

