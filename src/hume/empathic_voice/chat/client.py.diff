diff --git a/src/hume/empathic_voice/chat/client.py b/src/hume/empathic_voice/chat/client.py
index 2a3732f5..910917c9 100644
--- a/src/hume/empathic_voice/chat/client.py
+++ b/src/hume/empathic_voice/chat/client.py
@@ -1,11 +1,7 @@
 # This file was auto-generated by Fern from our API Definition.
 
-from contextlib import asynccontextmanager, contextmanager
-
-import json
 import typing
-
-from typing_extensions import deprecated
+from contextlib import asynccontextmanager, contextmanager
 
 import httpx
 import websockets.exceptions
@@ -14,34 +10,16 @@ from ...core.api_error import ApiError
 from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
 from ...core.request_options import RequestOptions
 from ...core.serialization import convert_and_respect_annotation_metadata
-from ...core.query_encoder import single_query_encoder
 from ..types.connect_session_settings import ConnectSessionSettings
 from .raw_client import AsyncRawChatClient, RawChatClient
-from .socket_client import AsyncChatSocketClient, ChatSocketClient, ChatConnectOptions
-
-from ...core.events import EventEmitterMixin, EventType
-from ...core.pydantic_utilities import parse_obj_as
-from ..types.assistant_input import AssistantInput
-from ..types.audio_input import AudioInput
-from ..types.pause_assistant_message import PauseAssistantMessage
-from ..types.resume_assistant_message import ResumeAssistantMessage
-from ..types.session_settings import SessionSettings
-from ..types.tool_error_message import ToolErrorMessage
-from ..types.tool_response_message import ToolResponseMessage
-from ..types.user_input import UserInput
-from .types.publish_event import PublishEvent
-from ..types.subscribe_event import SubscribeEvent
-
-from ...core.api_error import ApiError
-import asyncio
-
-from ...core.websocket import OnErrorHandlerType, OnMessageHandlerType, OnOpenCloseHandlerType
+from .socket_client import AsyncChatSocketClient, ChatSocketClient
 
 try:
     from websockets.legacy.client import connect as websockets_client_connect  # type: ignore
 except ImportError:
     from websockets import connect as websockets_client_connect  # type: ignore
 
+
 class ChatClient:
     def __init__(self, *, client_wrapper: SyncClientWrapper):
         self._raw_client = RawChatClient(client_wrapper=client_wrapper)
@@ -62,6 +40,7 @@ class ChatClient:
         self,
         *,
         access_token: typing.Optional[str] = None,
+        allow_connection: typing.Optional[bool] = None,
         config_id: typing.Optional[str] = None,
         config_version: typing.Optional[int] = None,
         event_limit: typing.Optional[int] = None,
@@ -69,7 +48,6 @@ class ChatClient:
         verbose_transcription: typing.Optional[bool] = None,
         api_key: typing.Optional[str] = None,
         session_settings: ConnectSessionSettings,
-        allow_connection: typing.Optional[bool] = None,
         request_options: typing.Optional[RequestOptions] = None,
     ) -> typing.Iterator[ChatSocketClient]:
         """
@@ -84,6 +62,9 @@ class ChatClient:
 
             For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).
 
+        allow_connection : typing.Optional[bool]
+            Allows external connections to this chat via the /connect endpoint.
+
         config_id : typing.Optional[str]
             The unique identifier for an EVI configuration.
 
@@ -137,6 +118,8 @@ class ChatClient:
         query_params = httpx.QueryParams()
         if access_token is not None:
             query_params = query_params.add("access_token", access_token)
+        if allow_connection is not None:
+            query_params = query_params.add("allow_connection", allow_connection)
         if config_id is not None:
             query_params = query_params.add("config_id", config_id)
         if config_version is not None:
@@ -149,12 +132,18 @@ class ChatClient:
             query_params = query_params.add("verbose_transcription", verbose_transcription)
         if api_key is not None:
             query_params = query_params.add("api_key", api_key)
-        if allow_connection is not None:
-            query_params = query_params.add("allow_connection", str(allow_connection).lower())
-        if session_settings is not None:
-            flattened_params = single_query_encoder("session_settings", session_settings)
-            for param_key, param_value in flattened_params:
-                query_params = query_params.add(param_key, str(param_value))
+        if (
+            convert_and_respect_annotation_metadata(
+                object_=session_settings, annotation=ConnectSessionSettings, direction="write"
+            )
+            is not None
+        ):
+            query_params = query_params.add(
+                "session_settings",
+                convert_and_respect_annotation_metadata(
+                    object_=session_settings, annotation=ConnectSessionSettings, direction="write"
+                ),
+            )
         ws_url = ws_url + f"?{query_params}"
         headers = self._raw_client._client_wrapper.get_headers()
         if request_options and "additional_headers" in request_options:
@@ -197,14 +186,14 @@ class AsyncChatClient:
         self,
         *,
         access_token: typing.Optional[str] = None,
+        allow_connection: typing.Optional[bool] = None,
         config_id: typing.Optional[str] = None,
         config_version: typing.Optional[int] = None,
         event_limit: typing.Optional[int] = None,
         resumed_chat_group_id: typing.Optional[str] = None,
         verbose_transcription: typing.Optional[bool] = None,
         api_key: typing.Optional[str] = None,
-        session_settings: typing.Optional[ConnectSessionSettings] = None,
-        allow_connection: typing.Optional[bool] = None,
+        session_settings: ConnectSessionSettings,
         request_options: typing.Optional[RequestOptions] = None,
     ) -> typing.AsyncIterator[AsyncChatSocketClient]:
         """
@@ -219,6 +208,9 @@ class AsyncChatClient:
 
             For more details, refer to the [Authentication Strategies Guide](/docs/introduction/api-key#authentication-strategies).
 
+        allow_connection : typing.Optional[bool]
+            Allows external connections to this chat via the /connect endpoint.
+
         config_id : typing.Optional[str]
             The unique identifier for an EVI configuration.
 
@@ -261,11 +253,6 @@ class AsyncChatClient:
 
         session_settings : ConnectSessionSettings
 
-        allow_connection : typing.Optional[bool]
-            Flag that allows the resulting Chat to accept secondary connections via
-            the control plane `/connect` endpoint. Defaults to `False` on the server.
-            Set to `True` to enable observer connections for the session.
-
         request_options : typing.Optional[RequestOptions]
             Request-specific configuration.
 
@@ -277,6 +264,8 @@ class AsyncChatClient:
         query_params = httpx.QueryParams()
         if access_token is not None:
             query_params = query_params.add("access_token", access_token)
+        if allow_connection is not None:
+            query_params = query_params.add("allow_connection", allow_connection)
         if config_id is not None:
             query_params = query_params.add("config_id", config_id)
         if config_version is not None:
@@ -289,12 +278,18 @@ class AsyncChatClient:
             query_params = query_params.add("verbose_transcription", verbose_transcription)
         if api_key is not None:
             query_params = query_params.add("api_key", api_key)
-        if allow_connection is not None:
-            query_params = query_params.add("allow_connection", str(allow_connection).lower())
-        if session_settings is not None:
-            flattened_params = single_query_encoder("session_settings", session_settings)
-            for param_key, param_value in flattened_params:
-                query_params = query_params.add(param_key, str(param_value))
+        if (
+            convert_and_respect_annotation_metadata(
+                object_=session_settings, annotation=ConnectSessionSettings, direction="write"
+            )
+            is not None
+        ):
+            query_params = query_params.add(
+                "session_settings",
+                convert_and_respect_annotation_metadata(
+                    object_=session_settings, annotation=ConnectSessionSettings, direction="write"
+                ),
+            )
         ws_url = ws_url + f"?{query_params}"
         headers = self._raw_client._client_wrapper.get_headers()
         if request_options and "additional_headers" in request_options:
@@ -315,234 +310,3 @@ class AsyncChatClient:
                 headers=dict(headers),
                 body="Unexpected error when initializing websocket connection.",
             )
-        
-    @deprecated("")
-    async def _wrap_on_open_close(
-        self, on_open: typing.Optional[OnOpenCloseHandlerType]
-    ):
-        if on_open is not None:
-            if asyncio.iscoroutinefunction(on_open):
-                await on_open()
-            else:
-                on_open()    
-
-    @deprecated("")
-    async def _wrap_on_error(
-        self, exc: Exception, on_error: typing.Optional[OnErrorHandlerType]
-    ) -> None:
-        if on_error is not None:
-            if asyncio.iscoroutinefunction(on_error):
-                await on_error(exc)
-            else:
-                on_error(exc)
-
-    @deprecated("")
-    async def _wrap_on_message(
-        self,
-        message: SubscribeEvent,
-        on_message: typing.Optional[OnMessageHandlerType[SubscribeEvent]],
-    ) -> None:
-        if on_message is not None:
-            if asyncio.iscoroutinefunction(on_message):
-                await on_message(message)
-            else:
-                on_message(message)
-
-    async def _process_connection(
-        self,
-        connection: AsyncChatSocketClient,
-        on_message: typing.Optional[OnMessageHandlerType],
-        on_error: typing.Optional[OnErrorHandlerType],
-    ) -> None:
-        async for message in connection:
-            try:
-                await self._wrap_on_message(message, on_message)
-            except Exception as exc:
-                await self._wrap_on_error(exc, on_error)
-
-    def _construct_ws_uri(self, options: typing.Optional[ChatConnectOptions]):
-        query_params = httpx.QueryParams()
-
-        api_key = self._raw_client._client_wrapper.api_key
-        if options is not None:
-            maybe_api_key = options.get("api_key")
-            if maybe_api_key is not None:
-                api_key = maybe_api_key
-            maybe_config_id = options.get("config_id")
-            if maybe_config_id is not None:
-                query_params = query_params.add("config_id", maybe_config_id)
-            maybe_config_version = options.get("config_version")
-            if maybe_config_version is not None:
-                query_params = query_params.add(
-                    "config_version", maybe_config_version
-                )
-            maybe_resumed_chat_group_id = options.get("resumed_chat_group_id")
-            if maybe_resumed_chat_group_id is not None:
-                query_params = query_params.add(
-                    "resumed_chat_group_id", maybe_resumed_chat_group_id
-                )
-            maybe_verbose_transcription = options.get("verbose_transcription")
-            if maybe_verbose_transcription is not None:
-                query_params = query_params.add(
-                    "verbose_transcription",
-                    "true" if maybe_verbose_transcription else "false",
-                )
-            elif api_key is not None:
-                query_params = query_params.add("apiKey", api_key)
-
-            maybe_voice_id = options.get("voice_id")
-            if maybe_voice_id is not None:
-                query_params = query_params.add("voice_id", maybe_voice_id)
-
-            maybe_session_settings = options.get("session_settings")
-            if maybe_session_settings is not None:
-                # Handle audio settings
-                audio = maybe_session_settings.get("audio")
-                if audio is not None:
-                    channels = audio.get("channels")
-                    if channels is not None:
-                        query_params = query_params.add(
-                            "session_settings[audio][channels]", str(channels)
-                        )
-                    encoding = audio.get("encoding")
-                    if encoding is not None:
-                        query_params = query_params.add(
-                            "session_settings[audio][encoding]", str(encoding)
-                        )
-                    sample_rate = audio.get("sample_rate")
-                    if sample_rate is not None:
-                        query_params = query_params.add(
-                            "session_settings[audio][sample_rate]", str(sample_rate)
-                        )
-
-                # Handle context settings
-                context = maybe_session_settings.get("context")
-                if context is not None:
-                    text = context.get("text")
-                    if text is not None:
-                        query_params = query_params.add(
-                            "session_settings[context][text]", str(text)
-                        )
-                    context_type = context.get("type")
-                    if context_type is not None:
-                        query_params = query_params.add(
-                            "session_settings[context][type]", str(context_type)
-                        )
-
-                # Handle top-level session settings
-                custom_session_id = maybe_session_settings.get("custom_session_id")
-                if custom_session_id is not None:
-                    query_params = query_params.add(
-                        "session_settings[custom_session_id]", str(custom_session_id)
-                    )
-
-                event_limit = maybe_session_settings.get("event_limit")
-                if event_limit is not None:
-                    query_params = query_params.add(
-                        "session_settings[event_limit]", str(event_limit)
-                    )
-
-                language_model_api_key = maybe_session_settings.get("language_model_api_key")
-                if language_model_api_key is not None:
-                    query_params = query_params.add(
-                        "session_settings[language_model_api_key]", str(language_model_api_key)
-                    )
-
-                system_prompt = maybe_session_settings.get("system_prompt")
-                if system_prompt is not None:
-                    query_params = query_params.add(
-                        "session_settings[system_prompt]", str(system_prompt)
-                    )
-
-                variables = maybe_session_settings.get("variables")
-                if variables is not None:
-                    query_params = query_params.add(
-                        "session_settings[variables]", json.dumps(variables)
-                    )
-
-                voice_id_setting = maybe_session_settings.get("voice_id")
-                if voice_id_setting is not None:
-                    query_params = query_params.add(
-                        "session_settings[voice_id]", str(voice_id_setting)
-                    )
-        elif api_key is not None:
-            query_params = query_params.add("apiKey", api_key)
-
-        base = self._raw_client._client_wrapper.get_environment().evi + "/chat"
-        return f"{base}?{query_params}"
-
-    @deprecated("Use .on() instead.")
-    @asynccontextmanager
-    async def connect_with_callbacks(
-        self,
-        options: typing.Optional[ChatConnectOptions] = None,
-        on_open: typing.Optional[OnOpenCloseHandlerType] = None,
-        on_message: typing.Optional[OnMessageHandlerType[SubscribeEvent]] = None,
-        on_close: typing.Optional[OnOpenCloseHandlerType] = None,
-        on_error: typing.Optional[OnErrorHandlerType] = None,
-    ) -> typing.AsyncIterator["AsyncChatSocketClient"]:
-        """
-        Parameters
-        ----------
-        on_open : Optional[OnOpenCloseHandlerType]
-            A callable to be invoked on the opening of the websocket connection.
-
-        on_message : Optional[OnMessageHandlerType[SubscribeEvent]]
-            A callable to be invoked on receiving a message from the websocket connection. This callback should expect a `SubscribeEvent` object.
-
-        on_close : Optional[OnOpenCloseHandlerType]
-            A callable to be invoked on the closing of the websocket connection.
-
-        on_error : Optional[OnErrorHandlerType]
-            A callable to be invoked on receiving an error from the websocket connection.
-
-        Yields
-        -------
-        AsyncIterator["AsyncChatSocketClient"]
-        """
-
-        ws_uri = self._construct_ws_uri(options)
-
-        background_task: typing.Optional[asyncio.Task[None]] = None
-
-        try:
-            async with websockets.connect(
-                ws_uri,
-                extra_headers=self._raw_client._client_wrapper.get_headers(),
-            ) as protocol:
-                await self._wrap_on_open_close(on_open)
-                connection = AsyncChatSocketClient(websocket=protocol)
-                background_task = asyncio.create_task(
-                    self._process_connection(connection, on_message, on_error)
-                )
-
-                yield connection
-
-        # Special case authentication errors
-        except websockets.exceptions.InvalidStatusCode as exc:
-            status_code: int = exc.status_code
-            if status_code == 401:
-                raise ApiError(
-                    status_code=status_code,
-                    body="Websocket initialized with invalid credentials.",
-                ) from exc
-            raise ApiError(
-                status_code=status_code,
-                body="Unexpected error when initializing websocket connection.",
-            ) from exc
-
-        # Except all other errors to apply the on_error handler
-        except Exception as exc:
-            await self._wrap_on_error(exc, on_error)
-            raise
-
-        # Finally, apply the on_close handler
-        finally:
-            if background_task is not None:
-                background_task.cancel()
-                try:
-                    await background_task
-                except asyncio.CancelledError:
-                    pass
-            await self._wrap_on_open_close(on_close)
-
