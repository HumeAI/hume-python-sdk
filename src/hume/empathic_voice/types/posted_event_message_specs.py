# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ...core.datetime_utils import serialize_datetime
from ...core.pydantic_utilities import deep_union_pydantic_dicts, pydantic_v1
from .posted_event_message_spec import PostedEventMessageSpec


class PostedEventMessageSpecs(pydantic_v1.BaseModel):
    """
    Collection of event messages returned by the server.

    Event messages are sent by the server when specific events occur during a chat session. These messages are used to configure behaviors for EVI, such as controlling how EVI starts a new conversation.
    """

    on_new_chat: typing.Optional[PostedEventMessageSpec] = pydantic_v1.Field(default=None)
    """
    Specifies the initial message EVI provides when a new chat is started, such as a greeting or welcome message.
    """

    on_inactivity_timeout: typing.Optional[PostedEventMessageSpec] = pydantic_v1.Field(default=None)
    """
    Specifies the message EVI provides when the chat is about to be disconnected due to a user inactivity timeout, such as a message mentioning a lack of user input for a period of time.
    
    Enabling an inactivity message allows developers to use this message event for "checking in" with the user if they are not responding to see if they are still active.
    
    If the user does not respond in the number of seconds specified in the `inactivity_timeout` field, then EVI will say the message and the user has 15 seconds to respond. If they respond in time, the conversation will continue; if not, the conversation will end.
    
    However, if the inactivity message is not enabled, then reaching the inactivity timeout will immediately end the connection.
    """

    on_max_duration_timeout: typing.Optional[PostedEventMessageSpec] = pydantic_v1.Field(default=None)
    """
    Specifies the message EVI provides when the chat is disconnected due to reaching the maximum chat duration, such as a message mentioning the time limit for the chat has been reached.
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        extra = pydantic_v1.Extra.allow
        json_encoders = {dt.datetime: serialize_datetime}
