diff --git a/src/hume/expression_measurement/stream/stream/socket_client.py b/src/hume/expression_measurement/stream/stream/socket_client.py
index fcd83929..85935e4e 100644
--- a/src/hume/expression_measurement/stream/stream/socket_client.py
+++ b/src/hume/expression_measurement/stream/stream/socket_client.py
@@ -1,18 +1,13 @@
 # This file was auto-generated by Fern from our API Definition.
 
-import base64
 import json
 import typing
 from json.decoder import JSONDecodeError
-from pathlib import Path
 
 import websockets
 import websockets.sync.connection as websockets_sync_connection
-
-from ....core.api_error import ApiError
 from ....core.events import EventEmitterMixin, EventType
 from ....core.pydantic_utilities import parse_obj_as
-from .types.config import Config
 from .types.stream_models_endpoint_payload import StreamModelsEndpointPayload
 from .types.subscribe_event import SubscribeEvent
 
@@ -83,74 +78,6 @@ class AsyncStreamSocketClient(EventEmitterMixin):
         """
         await self._send(data.dict())
 
-    async def send_facemesh(
-        self,
-        landmarks: typing.List[typing.List[typing.List[float]]],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        landmarks_str = json.dumps(landmarks)
-        payload = {
-            "data": landmarks_str,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def send_text(
-        self,
-        text: str,
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        payload = {
-            "data": text,
-            "models": config.dict() if config else None,
-            "raw_text": True,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def send_file(
-        self,
-        file_: typing.Union[str, Path],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        try:
-            with open(file_, "rb") as f:
-                bytes_data = base64.b64encode(f.read()).decode()
-        except:
-            if isinstance(file_, Path):
-                raise ApiError(body=f"Failed to open file: {file_}")
-            # If you cannot open the file, assume you were passed a b64 string, not a file path
-            bytes_data = str(file_)
-
-        payload = {
-            "data": bytes_data,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def get_job_details(self) -> StreamSocketClientResponse:
-        payload = {"job_details": True}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def reset(self) -> StreamSocketClientResponse:
-        payload = {"reset_stream": True}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
 
 class StreamSocketClient(EventEmitterMixin):
     def __init__(self, *, websocket: websockets_sync_connection.Connection):
@@ -210,71 +137,3 @@ class StreamSocketClient(EventEmitterMixin):
         Send a Pydantic model to the websocket connection.
         """
         self._send(data.dict())
-
-    def send_facemesh(
-        self,
-        landmarks: typing.List[typing.List[typing.List[float]]],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        landmarks_str = json.dumps(landmarks)
-        payload = {
-            "data": landmarks_str,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def send_text(
-        self,
-        text: str,
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        payload = {
-            "data": text,
-            "models": config.dict() if config else None,
-            "raw_text": True,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def send_file(
-        self,
-        file_: typing.Union[str, Path],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        try:
-            with open(file_, "rb") as f:
-                bytes_data = base64.b64encode(f.read()).decode()
-        except:
-            if isinstance(file_, Path):
-                raise ApiError(body=f"Failed to open file: {file_}")
-            # If you cannot open the file, assume you were passed a b64 string, not a file path
-            bytes_data = str(file_)
-
-        payload = {
-            "data": bytes_data,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def get_job_details(self) -> StreamSocketClientResponse:
-        payload = {"job_details": True}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def reset(self) -> StreamSocketClientResponse:
-        payload = {"reset_stream": True}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
