diff --git a/src/hume/expression_measurement/stream/stream/socket_client.py b/src/hume/expression_measurement/stream/stream/socket_client.py
index fcd8392..c0c0456 100644
--- a/src/hume/expression_measurement/stream/stream/socket_client.py
+++ b/src/hume/expression_measurement/stream/stream/socket_client.py
@@ -1,18 +1,13 @@
 # This file was auto-generated by Fern from our API Definition.
 
-import base64
 import json
 import typing
 from json.decoder import JSONDecodeError
-from pathlib import Path
 
 import websockets
 import websockets.sync.connection as websockets_sync_connection
-
-from ....core.api_error import ApiError
 from ....core.events import EventEmitterMixin, EventType
 from ....core.pydantic_utilities import parse_obj_as
-from .types.config import Config
 from .types.stream_models_endpoint_payload import StreamModelsEndpointPayload
 from .types.subscribe_event import SubscribeEvent
 
@@ -31,7 +26,10 @@ class AsyncStreamSocketClient(EventEmitterMixin):
 
     async def __aiter__(self):
         async for message in self._websocket:
-            yield parse_obj_as(StreamSocketClientResponse, json.loads(message))  # type: ignore
+            if isinstance(message, bytes):
+                yield message
+            else:
+                yield parse_obj_as(StreamSocketClientResponse, json.loads(message))  # type: ignore
 
     async def start_listening(self):
         """
@@ -46,8 +44,11 @@ class AsyncStreamSocketClient(EventEmitterMixin):
         await self._emit_async(EventType.OPEN, None)
         try:
             async for raw_message in self._websocket:
-                json_data = json.loads(raw_message)
-                parsed = parse_obj_as(StreamSocketClientResponse, json_data)  # type: ignore
+                if isinstance(raw_message, bytes):
+                    parsed = raw_message
+                else:
+                    json_data = json.loads(raw_message)
+                    parsed = parse_obj_as(StreamSocketClientResponse, json_data)  # type: ignore
                 await self._emit_async(EventType.MESSAGE, parsed)
         except (websockets.WebSocketException, JSONDecodeError) as exc:
             await self._emit_async(EventType.ERROR, exc)
@@ -66,6 +67,8 @@ class AsyncStreamSocketClient(EventEmitterMixin):
         Receive a message from the websocket connection.
         """
         data = await self._websocket.recv()
+        if isinstance(data, bytes):
+            return data  # type: ignore
         json_data = json.loads(data)
         return parse_obj_as(StreamSocketClientResponse, json_data)  # type: ignore
 
@@ -83,74 +86,6 @@ class AsyncStreamSocketClient(EventEmitterMixin):
         """
         await self._send(data.dict())
 
-    async def send_facemesh(
-        self,
-        landmarks: typing.List[typing.List[typing.List[float]]],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        landmarks_str = json.dumps(landmarks)
-        payload = {
-            "data": landmarks_str,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def send_text(
-        self,
-        text: str,
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        payload = {
-            "data": text,
-            "models": config.dict() if config else None,
-            "raw_text": True,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def send_file(
-        self,
-        file_: typing.Union[str, Path],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        try:
-            with open(file_, "rb") as f:
-                bytes_data = base64.b64encode(f.read()).decode()
-        except:
-            if isinstance(file_, Path):
-                raise ApiError(body=f"Failed to open file: {file_}")
-            # If you cannot open the file, assume you were passed a b64 string, not a file path
-            bytes_data = str(file_)
-
-        payload = {
-            "data": bytes_data,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def get_job_details(self) -> StreamSocketClientResponse:
-        payload = {"job_details": True}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
-    async def reset(self) -> StreamSocketClientResponse:
-        payload = {"reset_stream": True}
-        await self._websocket.send(json.dumps(payload))
-        return await self.recv()
-
 
 class StreamSocketClient(EventEmitterMixin):
     def __init__(self, *, websocket: websockets_sync_connection.Connection):
@@ -159,7 +94,10 @@ class StreamSocketClient(EventEmitterMixin):
 
     def __iter__(self):
         for message in self._websocket:
-            yield parse_obj_as(StreamSocketClientResponse, json.loads(message))  # type: ignore
+            if isinstance(message, bytes):
+                yield message
+            else:
+                yield parse_obj_as(StreamSocketClientResponse, json.loads(message))  # type: ignore
 
     def start_listening(self):
         """
@@ -174,8 +112,11 @@ class StreamSocketClient(EventEmitterMixin):
         self._emit(EventType.OPEN, None)
         try:
             for raw_message in self._websocket:
-                json_data = json.loads(raw_message)
-                parsed = parse_obj_as(StreamSocketClientResponse, json_data)  # type: ignore
+                if isinstance(raw_message, bytes):
+                    parsed = raw_message
+                else:
+                    json_data = json.loads(raw_message)
+                    parsed = parse_obj_as(StreamSocketClientResponse, json_data)  # type: ignore
                 self._emit(EventType.MESSAGE, parsed)
         except (websockets.WebSocketException, JSONDecodeError) as exc:
             self._emit(EventType.ERROR, exc)
@@ -194,6 +135,8 @@ class StreamSocketClient(EventEmitterMixin):
         Receive a message from the websocket connection.
         """
         data = self._websocket.recv()
+        if isinstance(data, bytes):
+            return data  # type: ignore
         json_data = json.loads(data)
         return parse_obj_as(StreamSocketClientResponse, json_data)  # type: ignore
 
@@ -210,71 +153,3 @@ class StreamSocketClient(EventEmitterMixin):
         Send a Pydantic model to the websocket connection.
         """
         self._send(data.dict())
-
-    def send_facemesh(
-        self,
-        landmarks: typing.List[typing.List[typing.List[float]]],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        landmarks_str = json.dumps(landmarks)
-        payload = {
-            "data": landmarks_str,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def send_text(
-        self,
-        text: str,
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        payload = {
-            "data": text,
-            "models": config.dict() if config else None,
-            "raw_text": True,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def send_file(
-        self,
-        file_: typing.Union[str, Path],
-        config: typing.Optional[Config] = None,
-        payload_id: typing.Optional[str] = None,
-    ) -> StreamSocketClientResponse:
-        try:
-            with open(file_, "rb") as f:
-                bytes_data = base64.b64encode(f.read()).decode()
-        except:
-            if isinstance(file_, Path):
-                raise ApiError(body=f"Failed to open file: {file_}")
-            # If you cannot open the file, assume you were passed a b64 string, not a file path
-            bytes_data = str(file_)
-
-        payload = {
-            "data": bytes_data,
-            "models": config.dict() if config else None,
-            "raw_text": False,
-            "payload_id": payload_id,
-        }
-        payload = {k: v for k, v in payload.items() if v is not None}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def get_job_details(self) -> StreamSocketClientResponse:
-        payload = {"job_details": True}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
-
-    def reset(self) -> StreamSocketClientResponse:
-        payload = {"reset_stream": True}
-        self._websocket.send(json.dumps(payload))
-        return self.recv()
